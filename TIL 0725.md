## 0725 TIL



역시 복사의 깊이 부분이 어려울만 했던듯하다.



 또 mutable 역시 완전히 이해할 수는 없는 부분이었다.



## 우선 mutable

일반적으로 mutable은 리스트, 셋, 딕셔너리 정도 말고는 없다.

id()로 확인한 메모리 주소를 기반으로 이를 나눈 듯하다.

리스트의 원소를 변경해도 id는 변하지 않는다-> mutable

셋이나 딕셔너리도 마찬가지



반면 스트링의 경우 

s='abc'라고 저장하고 첫 번째 글자를 변경 시도(s[0]='d' 등)하면 에러가 난다

어떻게든 s에 저장된 값을 변경한다면 id도 변경된다..

?궁금점? replace는 어떨까?

애당초에 replace 메소드는 변경된 a를 저장시키지 않는다. 즉 a 자체는 변하지 않는다.

a값이 리플레이스된 새로운 객체를 반환할 뿐.

당연히 새로운 객체와 기존 a는 id가 다르다

a=a.replace()하면 이는 재할당이기 때문에 당연히 id도 바뀔 것이다. 재할당의 경우 리스트 등 mutable을 재할당 해도 id는 바뀐다.





## 얕은 복사

[참고 사이트](https://wikidocs.net/16038)

리스트의 슬라이싱으로 새로운 값 할당 

ex) a=[1,2,3]

b=a[:]

a와 b의 id는 다르다

a==b: True

a is b: False

그러나

b[0]=5 등으로 b를 변경하면,

a

[1,2,3]

b

[5,2,3]

등으로 a는 변하지 않는다. (당연히 id 즉, 메모리가 다르니까)

이렇게 보면 깊은 복사 같지만!,

리스트 안에 리스트 등 mutable 안에 mutable의 경우 

a=[[1,2],[3,4]]

b=a[:]

역시 a,b의 id 다르다.

반면 

a[0], b[0] 등 그 내부 객체는 id가 같다!!

a[1].append(5) 등 a[1]값을 변경하면,

b도 바뀐다.

일반 copy도 얕은 복사이다.

 깊은 복사는 내부 객체들까지 모두 새롭게 카피된다

copy.deepcopy 해야만 깊은 복사가 된다.




